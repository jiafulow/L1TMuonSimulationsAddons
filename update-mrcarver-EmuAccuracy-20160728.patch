diff --git a/L1Trigger/L1TMuon/interface/deprecate/MuonTriggerPrimitive.h b/L1Trigger/L1TMuon/interface/deprecate/MuonTriggerPrimitive.h
index 7f10dc1..45efe6b 100644
--- a/L1Trigger/L1TMuon/interface/deprecate/MuonTriggerPrimitive.h
+++ b/L1Trigger/L1TMuon/interface/deprecate/MuonTriggerPrimitive.h
@@ -129,6 +129,7 @@ namespace L1TMuon {
 
     //copy
     TriggerPrimitive(const TriggerPrimitive&);
+	TriggerPrimitive(const TriggerPrimitive& tp1, const TriggerPrimitive& tp2);
 
     TriggerPrimitive& operator=(const TriggerPrimitive& tp);
     bool operator==(const TriggerPrimitive& tp) const;
diff --git a/L1Trigger/L1TMuon/src/MuonTriggerPrimitive.cc b/L1Trigger/L1TMuon/src/MuonTriggerPrimitive.cc
index ce957d8..02392b0 100644
--- a/L1Trigger/L1TMuon/src/MuonTriggerPrimitive.cc
+++ b/L1Trigger/L1TMuon/src/MuonTriggerPrimitive.cc
@@ -108,6 +108,27 @@ TriggerPrimitive::TriggerPrimitive(const CSCDetId& detid,
   _csc.cscID   = digi.getCSCID();
 }
 
+//CSC constructer from values
+TriggerPrimitive::TriggerPrimitive(const TriggerPrimitive& tp1, const TriggerPrimitive& tp2) {
+
+  _subsystem 	= TriggerPrimitive::kCSC;
+  _id 			= tp1.detId<CSCDetId>();
+  _csc.trknmb 	= tp1._csc.trknmb; 
+  _csc.valid 	= tp1._csc.valid; 
+  _csc.quality 	= tp1._csc.quality; 
+  _csc.keywire 	= tp2._csc.keywire; 
+  _csc.strip 	= tp1._csc.strip; 
+  _csc.pattern 	= tp1._csc.pattern; 
+  _csc.bend 	= tp1._csc.bend; 
+  _csc.bx 		= tp1._csc.bx; 
+  _csc.mpclink 	= tp1._csc.mpclink; 
+  _csc.bx0 		= tp1._csc.bx0; 
+  _csc.syncErr 	= tp1._csc.syncErr;
+  _csc.cscID 	= tp1._csc.cscID;
+
+}
+
+
 // constructor from RPC data
 TriggerPrimitive::TriggerPrimitive(const RPCDetId& detid,
 				   const unsigned strip,
diff --git a/L1Trigger/L1TMuonEndCap/interface/BXAnalyzer.h b/L1Trigger/L1TMuonEndCap/interface/BXAnalyzer.h
index 909ba43..fd05c1d 100644
--- a/L1Trigger/L1TMuonEndCap/interface/BXAnalyzer.h
+++ b/L1Trigger/L1TMuonEndCap/interface/BXAnalyzer.h
@@ -21,7 +21,7 @@ std::vector<std::vector<ConvertedHit>> GroupBX(std::vector<ConvertedHit> ConvHit
 	for(std::vector<ConvertedHit>::iterator i = ConvHits.begin();i != ConvHits.end();i++){
 	
 		int diff = i->BX() - CentralBX;
-		
+		  
 		if((diff > -3) && (diff < 1))
 			output[0].push_back(*i);
 		
@@ -32,6 +32,30 @@ std::vector<std::vector<ConvertedHit>> GroupBX(std::vector<ConvertedHit> ConvHit
 			output[1].push_back(*i);
 	}
 	
+	
+	
+	for(int i=0;i<3;i++){
+		
+		for(std::vector<ConvertedHit>::iterator it = output[i].begin();it != output[i].end();it++){
+			for(std::vector<ConvertedHit>::iterator it2 = it;it2 != output[i].end();it2++){
+			
+				if(it == it2) continue;
+				
+				if(it->Station() == it2->Station() && it->Id() == it2->Id() ){//add that phis have to be equal if assuming that a phi position can have only 2 possible thetas
+				
+					it->SetTheta2(it2->Theta());
+					it2->SetTheta2(it->Theta());
+					//std::cout<<"thetas = "<<it2->Theta()<<" and "<<it->Theta()<<"\n";
+					
+					it->AddTheta(it2->Theta());
+					it2->AddTheta(it->Theta());
+				}
+				
+			}
+		}
+	
+	}
+	
 	return output;
 
 }
@@ -40,32 +64,40 @@ std::vector<std::vector<ConvertedHit>> GroupBX(std::vector<ConvertedHit> ConvHit
 PatternOutput DeleteDuplicatePatterns(std::vector<PatternOutput> Pout){
 
 	std::vector<int> tmp (192,0);//was 128
-	std::vector<std::vector<int>> rank (4,tmp), layer(4,tmp),straightness(4,tmp);
+	std::vector<std::vector<int>> rank (4,tmp), layer(4,tmp),straightness(4,tmp),bxgroup(4,tmp);
 	std::vector<ConvertedHit> Hits;
 	
 	for(int i=0;i<3;i++){
 		
 		bool set = 0;
 		
+		
 		for(int zone=0;zone<4;zone++){
 			for(int strip=0;strip<192;strip++){//was 128
 				
-				if(Pout[i].detected.rank[zone][strip] >= rank[zone][strip]){
+				if(Pout[i].detected.rank[zone][strip] > rank[zone][strip]){
 					
 					rank[zone][strip] = Pout[i].detected.rank[zone][strip];
 					layer[zone][strip] = Pout[i].detected.layer[zone][strip];
 					straightness[zone][strip] = Pout[i].detected.straightness[zone][strip];
+					bxgroup[zone][strip] = i+1;
 					set = 1;
 				}
 			}
 		}
 		
-		if(set && (Pout[i].hits.size() > Hits.size())){
+		//if(set) std::cout<<"found pattern\n";
+		
+		if(set ){/*//&& (Pout[i].hits.size() >= Hits.size())){*/
 			
 			std::vector<ConvertedHit> test = Pout[i].hits;
 			
 			for(std::vector<ConvertedHit>::iterator it = test.begin();it != test.end();it++){
-				Hits.push_back(*it);
+			  
+			  
+			  	Hits.push_back(*it);
+			
+			  	//std::cout<<"adding hit in station "<<it->Station()<<" with strip = "<<it->Strip()<<"\n";
 			}
 		}
 		
@@ -77,6 +109,7 @@ PatternOutput DeleteDuplicatePatterns(std::vector<PatternOutput> Pout){
 	qout.rank = rank;
 	qout.layer = layer;
 	qout.straightness = straightness;
+	qout.bxgroup = bxgroup;
 	
 	PatternOutput output;
 	
@@ -86,3 +119,5 @@ PatternOutput DeleteDuplicatePatterns(std::vector<PatternOutput> Pout){
 	return output;
 
 }
+
+
diff --git a/L1Trigger/L1TMuonEndCap/interface/BestTracks.h b/L1Trigger/L1TMuonEndCap/interface/BestTracks.h
index 8edb794..4cc97f8 100644
--- a/L1Trigger/L1TMuonEndCap/interface/BestTracks.h
+++ b/L1Trigger/L1TMuonEndCap/interface/BestTracks.h
@@ -12,7 +12,7 @@ Date: 7/29/13
 
 std::vector<BTrack> BestTracks(std::vector<std::vector<DeltaOutput>> Dout){
 
-	//bool verbose = false;
+	bool verbose = false;
 
 	int larger[12][12] = {{0},{0}}, kill[12] = {0};
 	int exists[12] = {0};
@@ -24,6 +24,7 @@ std::vector<BTrack> BestTracks(std::vector<std::vector<DeltaOutput>> Dout){
 			for(int d=0;d<4;d++){
 				
 					phi[r][t][d] = Dout[r][t].GetMatchOut().PhiMatch()[r][t][d].Phi();
+					//if(phi[r][t][d] != -999) std::cout<<"phi = "<<phi[r][t][d]<<"\n";
 					id[r][t][d] = Dout[r][t].GetMatchOut().PhiMatch()[r][t][d].Id();
 			}
 		}
@@ -91,6 +92,11 @@ std::vector<BTrack> BestTracks(std::vector<std::vector<DeltaOutput>> Dout){
 			for(int j=0;j<12;j++){
 			
 				int rankj = Dout[j%4][j/4].GetWinner().Rank();
+				if(ranki && rankj){
+					
+					//std::cout<<"ranki = "<<ranki<<", and rankj = "<<rankj<<"\n";
+				
+				}
 				bool greater = (ranki > rankj);
 				bool equal = (ranki == rankj);
 			
@@ -181,10 +187,23 @@ std::vector<BTrack> BestTracks(std::vector<std::vector<DeltaOutput>> Dout){
 			
 				BTrack bests;
 				
-				//if(verbose) std::cout<<"Best Rank "<<n<<" = "<<Dout[i%4][i/4].GetWinner().Rank()<<"\n\n";
-				//if(verbose) std::cout<<"Phi = "<<Dout[i%4][i/4].Phi()<<" and Theta = "<<Dout[i%4][i/4].Theta()<<"\n\n";
-				//if(verbose) std::cout<<"Ph Deltas: "<<Dout[i%4][i/4].Deltas()[0][0]<<" "<<Dout[i%4][i/4].Deltas()[0][1]<<"   Th Deltas: "<<Dout[i%4][i/4].Deltas()[1][0]
-				//													     <<" "<<Dout[i%4][i/4].Deltas()[1][1]<<"\n\n";
+				
+				int mode = 0;
+				if(Dout[i%4][i/4].GetWinner().Rank() & 32)
+					mode |= 8;
+				if(Dout[i%4][i/4].GetWinner().Rank() & 8)
+					mode |= 4;
+				if(Dout[i%4][i/4].GetWinner().Rank() & 2)
+					mode |= 2;
+				if(Dout[i%4][i/4].GetWinner().Rank() & 1)
+					mode |= 1;
+				
+				if(verbose) std::cout<<"Best Rank "<<n<<" = "<<Dout[i%4][i/4].GetWinner().Rank()<<" and mode = "<<mode<<"\n\n";
+				if(verbose) std::cout<<"Phi = "<<Dout[i%4][i/4].Phi()<<" and Theta = "<<Dout[i%4][i/4].Theta()<<"\n\n";
+				if(verbose) std::cout<<"Ph Deltas: "<<Dout[i%4][i/4].Deltas()[0][0]<<" "<<Dout[i%4][i/4].Deltas()[0][1]<<" "<<Dout[i%4][i/4].Deltas()[0][2]<<" "<<Dout[i%4][i/4].Deltas()[0][3]
+										<<" "<<Dout[i%4][i/4].Deltas()[0][4]<<" "<<Dout[i%4][i/4].Deltas()[0][5]<<"   \nTh Deltas: "<<Dout[i%4][i/4].Deltas()[1][0]
+																	 <<" "<<Dout[i%4][i/4].Deltas()[1][1]<<" "<<Dout[i%4][i/4].Deltas()[1][2]<<" "<<Dout[i%4][i/4].Deltas()[1][3]
+																	 <<" "<<Dout[i%4][i/4].Deltas()[1][4]<<" "<<Dout[i%4][i/4].Deltas()[1][5]<<"\n\n";
 						
 				bests.winner = Dout[i%4][i/4].GetWinner();
 				bests.phi = Dout[i%4][i/4].Phi();
@@ -207,3 +226,25 @@ std::vector<BTrack> BestTracks(std::vector<std::vector<DeltaOutput>> Dout){
 
 
 }
+
+
+std::vector<std::vector<BTrack>> BestTracks_Hold(std::vector<std::vector<std::vector<DeltaOutput>>> Dout){
+
+	
+	BTrack tmp;
+	std::vector<BTrack> output (3,tmp);
+	std::vector<std::vector<BTrack>> full_output (3,output);
+
+	for(int bx=0;bx<3;bx++){
+	
+		//std::cout<<"Best tracks "<<bx<<"\n";
+		full_output[bx] = BestTracks(Dout[bx]);
+	
+	
+	}
+
+
+	return full_output;
+
+}
+
diff --git a/L1Trigger/L1TMuonEndCap/interface/Deltas.h b/L1Trigger/L1TMuonEndCap/interface/Deltas.h
index 59b00a1..ec654c7 100644
--- a/L1Trigger/L1TMuonEndCap/interface/Deltas.h
+++ b/L1Trigger/L1TMuonEndCap/interface/Deltas.h
@@ -15,6 +15,7 @@ DeltaOutput Deltas(MatchingOutput Mout, int zone, int winner){
 	
 	PhOutput phmatch = Mout.PhiMatch();
 	ThOutput thmatch = Mout.ThetaMatch();
+	ThOutput2 t2 = Mout.TMatch2();
 	
 	/*for comparison only
 	for(int xx=0;xx<4;xx++){
@@ -28,13 +29,26 @@ DeltaOutput Deltas(MatchingOutput Mout, int zone, int winner){
 	///Set Null dphi and dtheta arrays///
 	/////////////////////////////////////
 	int dphi[6] = {-999,-999,-999,-999,-999,-999};
-	int dtmp[6] = {-999,-999,-999,-999,-999,-999};
-	int dtmpi[6] = {-999,-999,-999,-999,-999,-999};
-	int dth[6][4] = {{-999,-999,-999,-999},{-999,-999,-999,-999},{-999,-999,-999,-999},{-999,-999,-999,-999},{-999,-999,-999,-999},{-999,-999,-999,-999}};
+	int dtmp2[6] = {-999,-999,-999,-999,-999,-999};
+	int dtmp2_ths[6][2] = {{-999,-999},{-999,-999},{-999,-999},{-999,-999},{-999,-999},{-999,-999}};
 	
 
 	for(int s1=0;s1<3;s1++){
 	
+	
+		/*for(unsigned int ts=0;ts<phmatch[zone][winner][s1].AllThetas().size();ts++){
+		
+			//if(!ts)
+			//	std::cout<<"St:"<<s1<<" thetas = ";
+			
+			std::cout<<phmatch[zone][winner][s1].AllThetas()[ts]<<", ";
+		
+			if(ts == phmatch[zone][winner][s1].AllThetas().size() -1)
+				std::cout<<"\n";
+		
+		}*/
+		
+	
 		for(int s2=s1+1;s2<4;s2++){
 		
 			///////////////////////// dphi index order runs like (dphi12,dphi13,dphi14,dphi23,dphi24,dphi34) hence the
@@ -54,18 +68,63 @@ DeltaOutput Deltas(MatchingOutput Mout, int zone, int winner){
 			///////////////////////// There is a further index on dTh because there are 4 dth combinations 
 			/// calc delta theta  /// possible if there are two theta segments for both stations. 
 			///////////////////////// EXPLAIN ABOUT [I+J] AND [I+J+1] 
+			
+			for(unsigned int t1=0;t1<phmatch[zone][winner][s1].AllThetas().size();t1++){
+				for(unsigned int t2=0;t2<phmatch[zone][winner][s2].AllThetas().size();t2++){
+			
+					int dth_tmp = phmatch[zone][winner][s2].AllThetas()[t2] - phmatch[zone][winner][s1].AllThetas()[t1];
+										
+					if(s1 == 0){
 					
-			for(int i=0;i<2;i++){
+						if(dtmp2[s2-1] == -999){
+							dtmp2[s2-1] = dth_tmp;
+							dtmp2_ths[s2-1][0] = phmatch[zone][winner][s1].AllThetas()[t1];
+							dtmp2_ths[s2-1][1] = phmatch[zone][winner][s2].AllThetas()[t2];
+						}
+						else if(abs(dth_tmp) < abs(dtmp2[s2-1])){
+							dtmp2[s2-1] = dth_tmp;
+							dtmp2_ths[s2-1][0] = phmatch[zone][winner][s1].AllThetas()[t1];
+							dtmp2_ths[s2-1][1] = phmatch[zone][winner][s2].AllThetas()[t2];
+						}
+					
+					
+					}
+					else{
+					
+					
+						if(dtmp2[s2+s1] == -999){
+							dtmp2[s2+s1] = dth_tmp;
+							dtmp2_ths[s1+s2][0] = phmatch[zone][winner][s1].AllThetas()[t1];
+							dtmp2_ths[s2+s1][1] = phmatch[zone][winner][s2].AllThetas()[t2];
+						}
+						else if(abs(dth_tmp) < abs(dtmp2[s2+s1])){
+							dtmp2[s2+s1] = dth_tmp;
+							dtmp2_ths[s1+s2][0] = phmatch[zone][winner][s1].AllThetas()[t1];
+							dtmp2_ths[s2+s1][1] = phmatch[zone][winner][s2].AllThetas()[t2];
+						}
+					
+					}
+			
+				}
+			}
+					
+			/*for(int i=0;i<2;i++){
 						
 					
 				for(int j=0;j<2;j++){
 						
-					int thi = thmatch[zone][winner][s1][i].Theta();
-					int thj = thmatch[zone][winner][s2][j].Theta();
+					//int thi = thmatch[zone][winner][s1][i].Theta();
+					//int thj = thmatch[zone][winner][s2][j].Theta();
+					
+					int thi = t2[zone][winner][s1][i];
+					int thj = t2[zone][winner][s2][j];
+					
+				//if(thi != -999 || thj != -999) std::cout<<"thi = "<<thi<<" and thj = "<<thj<<"\n";
+					
 					int deltath = thi - thj;
 					
 					
-					if((s1 == 0) && (thi != -999) && (thj != -999)){///need to fix still////
+					if((s1 == 0) && (thi != -999) && (thj != -999)){///need to fix still////???? do you? 6/7/2016 -> no 6/21/2016
 								
 						if(!i){dth[s2-1][i+j] = deltath;}
 						else{dth[s2-1][i+j+1] = deltath;}
@@ -79,7 +138,7 @@ DeltaOutput Deltas(MatchingOutput Mout, int zone, int winner){
 					}
 							
 				}
-			}
+			}*/
 		
 		}
 	} 
@@ -105,10 +164,10 @@ DeltaOutput Deltas(MatchingOutput Mout, int zone, int winner){
 	
 		//if(dphi[p] != -999 && verbose)
 		//	std::cout<<"dphi["<<p<<"] = "<<dphi[p]<<"\n\n";
-	
+		/*
 		for(int l=0;l<4;l++){
 		
-			//if(dth[p][l] != -999 && verbose){std::cout<<"dth["<<p<<"]["<<l<<"] = "<<dth[p][l]<<"\n\n";}
+			//if(dth[p][l] != -999 ){std::cout<<"dth["<<p<<"]["<<l<<"] = "<<dth[p][l]<<" and l = "<<l<<"\n\n";}
 		
 			if(abs(dth[p][l]) < fabs(dtmp[p])){//get best dtheta(i.e. the smallest)
 			
@@ -117,11 +176,18 @@ DeltaOutput Deltas(MatchingOutput Mout, int zone, int winner){
 				dtmp[p] = dth[p][l];
 				
 				dtmpi[p] = l;//says which combination of dth is the one to choose (because there are 4 possible as stated above^)
+				
+				std::cout<<"selected dtmp["<<p<<"] = "<<dtmp[p]<<" and dtmpi = "<<dtmpi[p]<<"\n";
 			}
 		}
+		*/
+		//if(dtmp2[p] != -999){
+		//  std::cout<<"dtmp2["<<p<<"] = "<<dtmp2[p]<<"\n";
+		//  std::cout<<"dtmp2_ths = "<<dtmp2_ths[p][0]<<" and "<<dtmp2_ths[p][1]<<"\n";
+		//}
 		
 		
-		if((abs(dtmp[p]) <= 4) && (dtmp[p] != -999)){//if dtheta is small enought and valid
+		if((abs(dtmp2[p]) <= 4) && (dtmp2[p] != -999)){///if dtheta is small enought and valid
 		
 			//std::cout<<"valid "<<p<<std::endl;
 		
@@ -129,25 +195,21 @@ DeltaOutput Deltas(MatchingOutput Mout, int zone, int winner){
 		} 
 	}
 	
-	//for(int q=0;q<3;q++){
-	//	if(vmask[q] && verbose)
-	//		std::cout<<"vmask["<<q<<"] = "<<vmask[q]<<std::endl;
-	//}
-	
+
 	
 	unsigned int vstat = vmask[0];
 	
-	//if(vstat && verbose){std::cout<<"vstat = "<<vstat<<std::endl;}
+	//if(vstat ){std::cout<<"vstat = "<<vstat<<std::endl;}
 	
 	if( !vstat || (vstat & vmask[1])){vstat |= vmask[1];}
 	
-	///if(vstat && verbose){std::cout<<"vstat = "<<vstat<<std::endl;}
+	//if(vstat ){std::cout<<"vstat = "<<vstat<<std::endl;}
 	
 	if( !vstat || (vstat & vmask[2])){vstat |= vmask[2];}
 	
-	//if(vstat && verbose){std::cout<<"vstat = "<<vstat<<std::endl;}
-	
-	const unsigned int vstatindex[11] = {0xc,0xa,0x6,0xe,0x9,0x5,0xd,0x3,0xb,0x7,0xf};
+	///if(vstat ){std::cout<<"vstat = "<<vstat<<std::endl;}//
+	/*
+	//const unsigned int vstatindex[11] = {0xc,0xa,0x6,0xe,0x9,0x5,0xd,0x3,0xb,0x7,0xf};
 	/////////////////////////////////////////////////////////////////////////////////////////////
 	/// vstatindex[11] is a list of possible combinations of valid and present stations
 	/// in order of increasing quality(i.e. if all stations are present and valid it's 
@@ -165,14 +227,14 @@ DeltaOutput Deltas(MatchingOutput Mout, int zone, int winner){
 	/// stations 1,2 and 3 present --> 0x7 --> 0111
 	/// all stations present       --> 0xf --> 1111
 	/////////////////////////////////////////////////////////////////////////////////////////////
-	const unsigned int viindex[2][11] = {{5,4,3,3,2,1,1,0,0,0,0},{5,4,3,5,2,1,5,0,4,3,3}};///index on which entry of vstatindex[11] to choose for both dphi and dtheta
-	
-	std::vector<int> d (2,-999);
+	//const unsigned int viindex[2][11] = {{5,4,3,3,2,1,1,0,0,0,0},{5,4,3,5,2,1,5,0,4,3,3}};///index on which entry of vstatindex[11] to choose for both dphi and dtheta
+	*/
+	std::vector<int> d (6,-999);
 	std::vector<std::vector<int>> deltas (2,d);//deltas[0]->dPhi & deltas[1]->dTheta
 	
 
 	
-	for(int c=0;c<11;c++){
+	/*for(int c=0;c<11;c++){
 	
 		if(vstat == vstatindex[c]){
 		
@@ -181,39 +243,38 @@ DeltaOutput Deltas(MatchingOutput Mout, int zone, int winner){
 			deltas[1][0] = dtmp[viindex[0][c]];
 			deltas[1][1] = dtmp[viindex[1][c]];
 		}
+	}*/
+	
+	for(int i=0;i<6;i++){
+	
+		//if(dtmp2[i] != -999) std::cout<<"dtmp2["<<i<<"] = "<<dtmp2[i]<<"\n";
+		
+		deltas[0][i] = dphi[i];
+		deltas[1][i] = dtmp2[i];
 	}
 	
 	///////////Set Precise Phi&Theta//////////
-	int phi = 0, theta = 0, id = 0;
+	int phi = 0, theta = 0;//, id = 0;
 	if(vstat & 2){//ME2 Present
-		
+	
 		//phi is simple, we have only one per station to choose from
 		phi = phmatch[zone][winner][1].Phi();
 		
 		//for theta, select delta to best station, use dtmpi as index
-		if(dtmp[0] != -999){
-		
-			if(dtmpi[0] < 2)
-				id = 1;
+		if(dtmp2[0] != -999){
 			
+			theta = dtmp2_ths[0][1];//t2[zone][winner][1][id];
 			
-			theta = thmatch[zone][winner][1][id].Theta();
 		}
-		else if(dtmp[3] != -999){
-			
-			if(dtmpi[3] > 1)
-				id = 1;
+		else if(dtmp2[3] != -999){
+		
 			
+			theta = dtmp2_ths[3][0];//t2[zone][winner][1][id];
 			
-			theta = thmatch[zone][winner][1][id].Theta();
 		}
-		else if(dtmp[4] != -999){
-			
-			if(dtmpi[4] > 1)
-				id = 1;
-			
-			
-			theta = thmatch[zone][winner][1][id].Theta();
+		else if(dtmp2[4] != -999){
+		
+			theta = dtmp2_ths[4][0];//t2[zone][winner][1][id];
 		}
 	
 	}
@@ -221,33 +282,21 @@ DeltaOutput Deltas(MatchingOutput Mout, int zone, int winner){
 	
 		phi = phmatch[zone][winner][2].Phi();
 		
-		if(dtmp[1] != -999){
+		if(dtmp2[1] != -999){
 		
-			if(dtmpi[1] < 2)
-				id = 1;
-			
-			
-			theta = thmatch[zone][winner][2][id].Theta();
+			theta = dtmp2_ths[1][1];//t2[zone][winner][2][id];
 		}
-		else if(dtmp[5] != -999){
-			
-			if(dtmpi[5] > 1)
-				id = 1;
-			
+		else if(dtmp2[5] != -999){
 			
-			theta = thmatch[zone][winner][2][id].Theta();
+			theta = dtmp2_ths[5][0];//t2[zone][winner][2][id];
 		}
 	}
 	else if(vstat & 8){//ME4 Present but not ME2 or ME3
 	
 		phi = phmatch[zone][winner][3].Phi();
-		if(dtmp[2] != -999){
+		if(dtmp2[2] != -999){
 		
-			if(dtmpi[2] < 2)
-				id = 1;
-			
-			
-			theta = thmatch[zone][winner][3][id].Theta();
+			theta = dtmp2_ths[2][1];//t2[zone][winner][3][id];
 		}
 	}
 	
@@ -256,15 +305,18 @@ DeltaOutput Deltas(MatchingOutput Mout, int zone, int winner){
 	
 	int rank = (Mout.Winners()[zone][winner].Rank()<<1);
 	
-	
+	//if(rank) std::cout<<"rank = "<<rank<<"\n";
 	///here we separate stations 3 and 4////
 	if(vstat & 8){rank |= 1;}else{rank &= 0x7e;}//if station 4 add to rank, else keep everythign and zero the bit which indicates station 4 is present
+	//if(rank) std::cout<<"rank = "<<rank<<"\n";
 	if(vstat & 4){rank |= 2;}else{rank &= 0x7d;}//if station 3 add to rank, else keep everythign and zero the bit which indicates station 3 is present
+	//if(rank) std::cout<<"rank = "<<rank<<"\n";
 	if(vstat & 2){rank |= 8;}else{rank &= 0x77;}//if station 2 add to rank, else keep everythign and zero the bit which indicates station 2 is present
+	//if(rank) std::cout<<"rank = "<<rank<<"\n";
 	if(vstat & 1){rank |= 32;}else{rank &= 0x5f;}//if station 1 add to rank, else keep everythign and zero the bit which indicates station 1 is present
-	
+	//if(rank) std::cout<<"sl rank = "<<rank<<"\n";
 	if(vstat == 0 || vstat == 1 || vstat == 2 || vstat == 4 || vstat == 8){rank = 0;}//removes single, and ME3--ME4 hit combinations
-	
+	//if(rank) std::cout<<"last rank = "<<rank<<"\n";
 	DeltaOutput output;
 	Mout.SetPhOut(phmatch);
 	Winner win = Mout.Winners()[zone][winner];
@@ -297,3 +349,29 @@ std::vector<std::vector<DeltaOutput>> CalcDeltas(MatchingOutput Mout){
 	
 	return out;
 }
+
+std::vector<std::vector<std::vector<DeltaOutput>>> CalcDeltas_Hold(std::vector<MatchingOutput> Mout){
+
+	DeltaOutput output;output.SetNull();
+	
+	std::vector<DeltaOutput> o (3,output);
+	std::vector<std::vector<DeltaOutput>> out (4,o);
+	std::vector<std::vector<std::vector<DeltaOutput>>> Output (3,out);
+	
+	for(int bx=0;bx<3;bx++){
+	
+		//std::cout<<"deltas "<<bx<<"\n";
+	
+		for(int zone=0;zone<4;zone++){
+	
+			for(int winner=0;winner<3;winner++){
+			
+				Output[bx][zone][winner] = Deltas(Mout[bx], zone, winner);
+			}
+		}
+		
+	}
+
+	return Output;
+
+}
diff --git a/L1Trigger/L1TMuonEndCap/interface/EmulatorClasses.h b/L1Trigger/L1TMuonEndCap/interface/EmulatorClasses.h
index 8162d48..d59d550 100644
--- a/L1Trigger/L1TMuonEndCap/interface/EmulatorClasses.h
+++ b/L1Trigger/L1TMuonEndCap/interface/EmulatorClasses.h
@@ -21,13 +21,13 @@ class ConvertedHit{
 		void SetValues(int phi,int theta,int ph_hit,int phzvl,int station,int sub,int id,int quality,int pattern,int wire,int strip,int BX){
 		
 			_ph = phi;_th = theta;_phit = ph_hit;_phzvl = phzvl;_sta = station;_sub = sub;_id = id;_qual = quality;_patt = pattern;
-			_wire = wire;_strip = strip;_zhit = -999;_bx = BX;
+			_wire = wire;_strip = strip;_zhit = -999;_bx = BX;_th2 = -999;
 		
 		};
 		
 		void SetNull(){
 		
-			_ph = -999;_th = -999;_phit = -999;_phzvl = -999;_sta = -999;_sub = -999;_id = -999;_qual = -999;_patt = 0;
+			_ph = -999;_th = -999;_th2 = -999;_phit = -999;_phzvl = -999;_sta = -999;_sub = -999;_id = -999;_qual = -999;_patt = 0;
 			_wire = -999;_strip = -999;_zhit = -999;
 		};
 		
@@ -47,6 +47,8 @@ class ConvertedHit{
 		
 		void SetTheta(int theta){_th = theta;};
 		
+		void SetTheta2(int theta2){_th2 = theta2;};
+		
 		void SetTP(TriggerPrimitive tp){_tp = tp;};
 		
 		void SetSectorIndex(int sectorIndex){_sectorIndex = sectorIndex;};
@@ -55,9 +57,12 @@ class ConvertedHit{
 		
 		void SetNeighbor(int neighbor){_isNeighbor = neighbor;};
 		
+		void AddTheta(int theta){_thetas.push_back(theta);};
+		
 		
 		int Phi(){return _ph;};
 		int Theta(){return _th;};
+		int Theta2(){return _th2;};
 		int Ph_hit(){return _phit;};
 		int Phzvl(){return _phzvl;};
 		int Station(){return _sta;};
@@ -73,13 +78,14 @@ class ConvertedHit{
 		int IsNeighbor(){return _isNeighbor;};
 		TriggerPrimitive TP(){return _tp;};
 		std::vector<int> ZoneContribution(){return _zonecont;};
+		std::vector<int> AllThetas(){return _thetas;};
 		
 		
 	private:
 	
-		int _ph,_th,_phit,_phzvl,_sta,_sub,_id,_qual,_patt,_wire,_strip,_zhit,_bx, _sectorIndex, _isNeighbor;
+		int _ph,_th, _th2,_phit,_phzvl,_sta,_sub,_id,_qual,_patt,_wire,_strip,_zhit,_bx, _sectorIndex, _isNeighbor;
 		TriggerPrimitive _tp;
-		std::vector<int> _zonecont;
+		std::vector<int> _zonecont, _thetas;
 
 };
 
@@ -92,7 +98,7 @@ struct ZonesOutput{
 
 struct QualityOutput{
 
-	Code rank, layer,straightness;
+	Code rank, layer,straightness, bxgroup;
 
 	
 };
@@ -102,6 +108,7 @@ struct PatternOutput{
 
 	QualityOutput detected;
 	std::vector<ConvertedHit> hits;
+	//int bxgroup;
 
 };
 
@@ -121,6 +128,7 @@ class Winner{
 		
 		int Rank(){return _rank;}
 		int Strip(){return _strip;}
+		int BXGroup(){return _bxgroup;}
 		
 		void SetValues(int rank, int strip){
 		
@@ -131,11 +139,17 @@ class Winner{
 		
 			_rank = rank;
 		}
+		
+		void SetBXGroup(int bxgroup){
+		
+			_bxgroup = bxgroup;
+		
+		}
 	
 	private:
 	
 	
-		int _rank, _strip;
+		int _rank, _strip, _bxgroup;
 		
 };
 
@@ -160,6 +174,7 @@ class SortingOutput{
 
 
 typedef std::vector<std::vector<std::vector<std::vector<ConvertedHit>>>> ThOutput;
+typedef std::vector<std::vector<std::vector<std::vector<int>>>> ThOutput2;
 typedef std::vector<std::vector<std::vector<ConvertedHit>>> PhOutput;
 class MatchingOutput{
 
@@ -179,11 +194,19 @@ class MatchingOutput{
 			_segment = segment;
 		}
 		
+		void setM2(ThOutput2 t2){
+		
+			_th_output2 = t2;
+		
+		
+		}
+		
 		
 		
 		std::vector<ConvertedHit> Hits(){return _hits;}; 
 		std::vector<std::vector<Winner>> Winners(){return _winners;};
 		ThOutput ThetaMatch(){return _th_output;};
+		ThOutput2 TMatch2(){return _th_output2;};
 		PhOutput PhiMatch(){return _ph_output;};
 		std::vector<int> Segment(){return _segment;};
 		
@@ -193,6 +216,7 @@ class MatchingOutput{
 		std::vector<ConvertedHit> _hits;
 		std::vector<std::vector<Winner>> _winners;
 		ThOutput _th_output;
+		ThOutput2 _th_output2;
 		PhOutput _ph_output;
 		std::vector<int> _segment;
 	
diff --git a/L1Trigger/L1TMuonEndCap/interface/Matching.h b/L1Trigger/L1TMuonEndCap/interface/Matching.h
index f6ef7ee..528576f 100644
--- a/L1Trigger/L1TMuonEndCap/interface/Matching.h
+++ b/L1Trigger/L1TMuonEndCap/interface/Matching.h
@@ -16,7 +16,7 @@ MatchingOutput PhiMatching(SortingOutput Sout){
 	std::vector<ConvertedHit> Thits = Sout.Hits();
 	std::vector<std::vector<Winner>> Winners = Sout.Winners();
 	std::vector<int> segment (4,0);
-	int phdiff[4] = {15,15,8,8};
+	int phdiff[4] = {15,7,7,7};
 	
 	/////////////////////////////////////////
 	//// Set Null Ph and Th outputs /////////
@@ -25,6 +25,11 @@ MatchingOutput PhiMatching(SortingOutput Sout){
 	std::vector<ConvertedHit> p (4,tt);std::vector<std::vector<ConvertedHit>> pp (3,p);
 	PhOutput ph_output (4,pp);
 					
+	int t2 = -999;
+	std::vector<int> q2 (2,t2);
+	std::vector<std::vector<int>> qq2 (4,q2);std::vector<std::vector<std::vector<int>>> qqq2 (3,qq2);
+	ThOutput2 th_output2 (4,qqq2);
+	
 	
 	std::vector<ConvertedHit> q (2,tt);
 	std::vector<std::vector<ConvertedHit>> qq (4,q);std::vector<std::vector<std::vector<ConvertedHit>>> qqq (3,qq);
@@ -41,75 +46,120 @@ MatchingOutput PhiMatching(SortingOutput Sout){
 			
 			if(Winners[z][w].Rank()){//is there a winner present?	
 			
-				if(verbose) std::cout<<"\n\nWinner position-"<<Winners[z][w].Strip()<<". Zone = "<<z<<std::endl;			
+				if(verbose) std::cout<<"\n\nWinner position-"<<Winners[z][w].Strip()<<". Zone = "<<z<<std::endl;
+				if(verbose) std::cout<<"Number of possible hits to match = "<<Thits.size()<<"\n";			
 				
-				for(std::vector<ConvertedHit>::iterator i = Thits.begin();i != Thits.end();i++){//Possible associated hits
+				//for(std::vector<ConvertedHit>::iterator i = Thits.begin();i != Thits.end();i++){//Possible associated hits
+				for(int i = Thits.size() - 1;i > -1;i--){//Possible associated hits
+				//for(unsigned int i=0;i<Thits.size();i++){//Possible associated hits
 				
-					//int id = i->Id();
+					//int id = Thits[i].Id();
 					
-					if(verbose) std::cout<<"strip = "<<i->Strip()<<", keywire = "<<i->Wire()<<" and zhit-"<<i->Zhit()<<std:: endl;
+					if(verbose) std::cout<<"station = "<<Thits[i].Station()<<", strip = "<<Thits[i].Strip()<<", keywire = "<<Thits[i].Wire()<<" and zhit-"<<Thits[i].Zhit()<<", bx = "<<Thits[i].BX()<<", phi>>5 = "<<(Thits[i].Phi()>>5)<<"\n";
 
 					// Unused variable
-					/* bool inzone = 0;///Is the converted hit in the zone we're looking at now? */
-					/* for(std::vector<int>::iterator znc = i->ZoneContribution().begin();znc != i->ZoneContribution().end();znc++){ */
-					/* 	if((*znc) == z) */
-					/* 		inzone = 1;//yes */
-					/* } */
+					/* bool inzone = 0;///Is the converted hit in the zone we're looking at now? 
+					 for(std::vector<int>::iterator znc = Thits[i].ZoneContribution().begin();znc != Thits[i].ZoneContribution().end();znc++){ 
+					  if((*znc) == z) 
+						  inzone = 1;//yes 
+					 } */
+					
+					bool inBXgroup = false;
+					
+					switch(Winners[z][w].BXGroup()){
+					
+					
+						case 1: if(Thits[i].BX() > 3 && Thits[i].BX() < 7) inBXgroup = true;break;
+						case 2: if(Thits[i].BX() > 4 && Thits[i].BX() < 8) inBXgroup = true;break;
+						case 3: if(Thits[i].BX() > 5 && Thits[i].BX() < 9) inBXgroup = true;break;
+						default: inBXgroup = false;
+					
+					
+					
+					}
 					
 					////////////////////////////////////////////////////////////////////////////////////////////
 					/////////////////// Setting the matched hits based on phi //////////////////////////////////
 					////////////////////////////////////////////////////////////////////////////////////////////
-					int setstation = i->Station() - 1;
-					//bool one = ((z == 3) && (i->Station() > 1));                //Zone 3 is handled differently so we
-					//bool two = ((z == 3) && (i->Station() == 1) && (id > 3));   //have this conditions here
+					int setstation = Thits[i].Station() - 1;
 					bool setphi = 0;
-					//if(one || two)
-					//	setstation++;
 					
 					if(verbose)
 						std::cout<<"setstation = "<<setstation<<std::endl;
+						
+					//if(verbose){
 					
-					if((fabs((Winners[z][w].Strip()) - i->Zhit()) <= phdiff[setstation]) ){//is close to winner keystrip and in same zone?
+					//	std::cout<<"Winners[z][w].Strip(): "<<Winners[z][w].Strip()<<" + 1 - Thits[i].Zhit():"<<Thits[i].Zhit()<<" = "<<(Winners[z][w].Strip() + 1) - Thits[i].Zhit()<<". Thits[i].Phi()>>5 = "<<(Thits[i].Phi() >> 5)<<"\n";
+					//}
+					
+					if((fabs(Winners[z][w].Strip() - (Thits[i].Phi()>>5)) <= phdiff[setstation]) && inBXgroup /*&& inzone*/){//is close to winner keystrip and in same zone?
 					
 						if(ph_output[z][w][setstation].Phi() == -999){//has this already been set? no
 						
 							if(verbose) std::cout<<"hasn't been set"<<std::endl;
 							
-							ph_output[z][w][setstation] = (*i);
+							ph_output[z][w][setstation] = (Thits[i]);
 							
-							if(verbose) std::cout<<"set with strip-"<<i->Strip()<<", and wire-"<<i->Wire()<<std::endl;
+							if(verbose) std::cout<<"set with strip-"<<Thits[i].Strip()<<", and wire-"<<Thits[i].Wire()<<std::endl;
 							setphi = true;
 						}
 						else{//if yes, find absolute difference between zhit of each hit and keystrip
 						
 							if(verbose) std::cout<<"has already been set"<<std::endl;
 						
-							int d1 = fabs(ph_output[z][w][setstation].Zhit() - Winners[z][w].Strip());
-							int d2 = fabs(i->Zhit() - Winners[z][w].Strip());
+							int d1 = fabs((ph_output[z][w][setstation].Phi()>>5) - Winners[z][w].Strip());
+							int d2 = fabs((Thits[i].Phi()>>5) - Winners[z][w].Strip());
+							
+							if(verbose) std::cout<<"d1 = "<<d1<<" and d2 = "<<d2<<"\n";
 							
 							if(d2 < d1){//if new hit is closer then replace phi
 							
-								if(verbose) std::cout<<"this is closer strip-"<<i->Strip()<<", and wire-"<<i->Wire()<<std::endl;
+								if(verbose) std::cout<<"this is closer strip-"<<Thits[i].Strip()<<", and wire-"<<Thits[i].Wire()<<std::endl;
 								
-								ph_output[z][w][setstation] = (*i);
+								ph_output[z][w][setstation] = (Thits[i]);
 								
 								setphi = true;
 							
 							}
 							
+							
 						}
 						
 						
 						/////////////////////////////////////////////////////////////////////////////////////
 						/////////////  Setting matched theta values; Take both of two from same chamber /////
 						/////////////////////////////////////////////////////////////////////////////////////
+						
+						//if((th_output[z][w][setstation][0].Theta() != -999) && (th_output[z][w][setstation][0].Id() == Thits[i].Id())){//if same chamber take as well
+						//		th_output[z][w][setstation][1] = (Thits[i]);
+						//		if(verbose) std::cout<<"in here with set th = "<<th_output[z][w][setstation][0].Theta()<<" and new th = "<<Thits[i].Theta()<<"\n";
+						//	}
 					
-						if(setphi)//only set if phi was also set
-							th_output[z][w][setstation][0] = (*i);
+						if(setphi){//only set if phi was also set
+						
+							th_output2[z][w][setstation][0] = Thits[i].Theta();
+						
+							/*if(th_output[z][w][setstation][0].Theta() == -999){
+								th_output[z][w][setstation][0] = (Thits[i]);
+							}
+							else if((th_output[z][w][setstation][0].Theta() != -999) && (th_output[z][w][setstation][0].Id() == Thits[i].Id())){//if same chamber take as well
+								th_output[z][w][setstation][1] = (Thits[i]);
+								if(verbose) std::cout<<"in here with set th = "<<th_output[z][w][setstation][0].Theta()<<" and new th = "<<Thits[i].Theta()<<"\n";
+							}*/
+							
 							
-						if((th_output[z][w][setstation][0].Theta() != -999) && (th_output[z][w][setstation][0].Id() == i->Id()))//if same chamber take as well
-							th_output[z][w][setstation][1] = (*i);
+							//if((th_output[z][w][setstation][0].Theta() != -999) && (th_output[z][w][setstation][0].Id() == Thits[i].Id())){//if same chamber take as well
+							//	th_output[z][w][setstation][1] = (Thits[i]);
+							//	if(verbose) std::cout<<"in here with set th = "<<th_output[z][w][setstation][0].Theta()<<" and new th = "<<Thits[i].Theta()<<"\n";
+							//}
+							//else{
+							//	th_output[z][w][setstation][0] = (Thits[i]);
+								
+								if(Thits[i].Theta2() != -999)
+									th_output2[z][w][setstation][1] = Thits[i].Theta2();
+							//}
 						
+						}
 					
 					}
 				}
@@ -122,6 +172,26 @@ MatchingOutput PhiMatching(SortingOutput Sout){
 
 	MatchingOutput output;
 	output.SetValues(th_output,ph_output,Thits,Winners,segment);
+	output.setM2(th_output2);
+	
+	return output;
+}
+
+std::vector<MatchingOutput> PhiMatching_Hold(std::vector<SortingOutput> Sout){
+
+	MatchingOutput tmp;
+	std::vector<MatchingOutput> output (3,tmp);
+
+
+	if(Sout.size() != 3)
+		std::cout<<"Incorrect BX window size for sorting output. Please check to see why.\n";
+
+	for(int i=0;i<3;i++){
+	
+	//	std::cout<<"begin matching on BX group "<<i<<"\n";
+		output[i] = PhiMatching(Sout[i]);
+	
+	}
 	
 	return output;
 }
diff --git a/L1Trigger/L1TMuonEndCap/interface/SortSector.h b/L1Trigger/L1TMuonEndCap/interface/SortSector.h
index 668e22d..b89bbca 100644
--- a/L1Trigger/L1TMuonEndCap/interface/SortSector.h
+++ b/L1Trigger/L1TMuonEndCap/interface/SortSector.h
@@ -23,7 +23,8 @@ SortingOutput  SortSect(PatternOutput Pout){
 		for(int zone=0;zone<4;zone++){
 			
 			temp[zone].SetValues(0,0);
-			for(int strip=0;strip<192;strip++){//was 128
+			/*//for(int strip=0;strip<192;strip++){//was 128*/
+			for(int strip=191;strip>-1;strip--){//was 128
 		
 				if(Detected.rank[zone][strip] > temp[zone].Rank()){temp[zone].SetValues(Detected.rank[zone][strip], strip);}
 		
@@ -31,14 +32,79 @@ SortingOutput  SortSect(PatternOutput Pout){
 		
 			if(temp[zone].Rank()){
 				
-				
 				//removes rank as not to count twice/////////////////
 				Detected.rank[zone][temp[zone].Strip()] = 0;
 				Detected.layer[zone][temp[zone].Strip()] = 0;
 				Detected.straightness[zone][temp[zone].Strip()] = 0;
 				/////////////////////////////////////////////////////
+				Winners[zone][i] = temp[zone];
+				Winners[zone][i].SetBXGroup(Detected.bxgroup[zone][temp[zone].Strip()]);
+			}
+		
+		
+		}
+	
+		
+	}
+	
+	
+	/////////////////////////////////
+	// Printing for Comparison///////
+	/////////////////////////////////
+	/*
+	for(int l=0;l<4;l++){//zone loop
+			
+		for(int m=0;m<3;m++){
+			
+			if(Winners[l][m].Rank())
+				std::cout<<"Winner["<<l<<"]["<<m<<"]!-----Q:"<<Winners[l][m].Rank()<<"  S:"<<Winners[l][m].Strip()<<"\n";
+			
+		}
+	}
+	*/	
+	/////////////////////////////////
+	/////////////////////////////////
+	/////////////////////////////////
+	
+	SortingOutput output;
+	
+	output.SetValues(Winners,Pout.hits);
+	
+	return output;
+	
+}
+
+SortingOutput  SortSector(PatternOutput Pout, int bxgroup){
+	
+	////variable declaration ///////////////////////////
+	QualityOutput Detected = Pout.detected;
+	Winner tmp;tmp.SetValues(0,0);
+	std::vector<Winner> tmmp (3,tmp);
+	std::vector<std::vector<Winner>> Winners (4,tmmp);
+	////////////////////////////////////////////////////
+	
+	for(int i=0;i<3;i++){//loop to get three best
+	
+		Winner temp[4];
+		for(int zone=0;zone<4;zone++){
+			
+			temp[zone].SetValues(0,0);
+			/*//for(int strip=0;strip<192;strip++){//was 128*/
+			for(int strip=191;strip>-1;strip--){//was 128
+		
+				if(Detected.rank[zone][strip] > temp[zone].Rank()){temp[zone].SetValues(Detected.rank[zone][strip], strip);}
+		
+			}
+			
+			if(temp[zone].Rank()){
 				
+				//removes rank as not to count twice/////////////////
+				Detected.rank[zone][temp[zone].Strip()] = 0;
+				Detected.layer[zone][temp[zone].Strip()] = 0;
+				Detected.straightness[zone][temp[zone].Strip()] = 0;
+				/////////////////////////////////////////////////////
 				Winners[zone][i] = temp[zone];
+				Winners[zone][i].SetBXGroup(bxgroup);
 			}
 		
 		
@@ -75,3 +141,23 @@ SortingOutput  SortSect(PatternOutput Pout){
 }
 
 
+std::vector<SortingOutput> SortSect_Hold(std::vector<PatternOutput> Pout){
+
+	SortingOutput tmp;
+	std::vector<SortingOutput> output (3,tmp);
+	
+	if(Pout.size() != 3)
+		std::cout<<"Incorrect number of BX windows! Please check to see why.\n";
+	
+	for(int i=0;i<3;i++){
+	
+		//std::cout<<"start sorting on BX group "<<i<<"\n";
+	
+		output[i] = SortSector(Pout[i], i+1);
+	
+	}
+	
+	return output;
+}
+
+
diff --git a/L1Trigger/L1TMuonEndCap/plugins/L1TMuonEndCapTrackProducer.cc b/L1Trigger/L1TMuonEndCap/plugins/L1TMuonEndCapTrackProducer.cc
index f11ab07..8cc4633 100644
--- a/L1Trigger/L1TMuonEndCap/plugins/L1TMuonEndCapTrackProducer.cc
+++ b/L1Trigger/L1TMuonEndCap/plugins/L1TMuonEndCapTrackProducer.cc
@@ -66,6 +66,7 @@ void L1TMuonEndCapTrackProducer::produce(edm::Event& ev,
   std::auto_ptr<l1t::EMTFHitExtraCollection> OutputHits (new l1t::EMTFHitExtraCollection);
 
   std::vector<BTrack> PTracks[NUM_SECTORS];
+  std::vector<BTrack> PTracks_BX[NUM_SECTORS][3];
 
   std::vector<TriggerPrimitive> tester;
   //std::vector<InternalTrack> FoundTracks;
@@ -113,25 +114,61 @@ void L1TMuonEndCapTrackProducer::produce(edm::Event& ev,
    // ev.getByLabel(*tpsrc,tps);
     auto tp = out.cbegin();
     auto tpend = out.cend();
+	
+	//bool S1 =false;
 
     for( ; tp != tpend; ++tp ) {
       if(tp->subsystem() == 1)
       {
 		//TriggerPrimitiveRef tpref(out,tp - out.cbegin());
 
-		tester.push_back(*tp);
+		//tester.push_back(*tp);
 
 		//std::cout<<"\ntrigger prim found station:"<<tp->detId<CSCDetId>().station()<<std::endl;
       }
 
      }
+	 
+	 for(unsigned int i1=0;i1<out.size();i1++){
+	 
+	 	tester.push_back(out[i1]);
+		
+		//if(out[i1].detId<CSCDetId>().triggerSector() == 1 && out[i1].detId<CSCDetId>().endcap() == 1)
+		//	S1 = true;
+	 
+	 	for(unsigned int i2=i1+1;i2<out.size();i2++){
+	 
+	 		if(i1 == i2) continue;
+			
+			if(out[i1].detId<CSCDetId>().station() == out[i2].detId<CSCDetId>().station() &&
+				out[i1].detId<CSCDetId>().endcap() == out[i2].detId<CSCDetId>().endcap() &&
+				out[i1].detId<CSCDetId>().triggerSector() == out[i2].detId<CSCDetId>().triggerSector() &&
+				out[i1].detId<CSCDetId>().ring() == out[i2].detId<CSCDetId>().ring() &&
+				out[i1].detId<CSCDetId>().chamber() == out[i2].detId<CSCDetId>().chamber() &&
+				out[i1].Id() == out[i2].Id() && out[i1].getBX() == out[i2].getBX()){ 
+						
+						TriggerPrimitive NewWire1(out[i1],out[i2]);
+						TriggerPrimitive NewWire2(out[i2],out[i1]);
+						tester.push_back(NewWire1);
+						tester.push_back(NewWire2);
+						
+				}
+	 
+	 	}
+	 }
+	 
+	 
+	 //if(S1)
+	 //	std::cout<<"12345\n12345\n12345\n12345\n12345\n12345\n12345\n12345\n12345\n12345\n";
+	 
+	 
    //}
   std::vector<ConvertedHit> CHits[NUM_SECTORS];
-  MatchingOutput MO[NUM_SECTORS];
+  //MatchingOutput MO[NUM_SECTORS];
 
 for(int SectIndex=0;SectIndex<NUM_SECTORS;SectIndex++){//perform TF on all 12 sectors
 
-
+//if(SectIndex != 2) continue;
 
   //////////////////////////////////////////////////////  Input is raw hit information from
   ///////////////// TP Conversion //////////////////////  Output is vector of Converted Hits
@@ -235,8 +272,9 @@ for(int SectIndex=0;SectIndex<NUM_SECTORS;SectIndex++){//perform TF on all 12 se
 
 
   std::vector<PatternOutput> Pout = Patterns(Zout);
+  std::vector<PatternOutput> Pout_Hold = Pout;
 
-  PatternOutput Test = DeleteDuplicatePatterns(Pout);
+  //PatternOutput Test = DeleteDuplicatePatterns(Pout);
 
   //PrintQuality(Test.detected);
 
@@ -246,23 +284,30 @@ for(int SectIndex=0;SectIndex<NUM_SECTORS;SectIndex++){//perform TF on all 12 se
   ///////Finding 3 Best Pattern//
   ///////////////////////////////
 
-  SortingOutput Sout = SortSect(Test);
+  //SortingOutput Sout = SortSect(Test);
+  
+  std::vector<SortingOutput> Sout_Hold = SortSect_Hold(Pout_Hold);
 
 
   //////////////////////////////////
   ///////// Match ph patterns ////// Loops over each sorted pattern and then loops over all possible triggerprimitives which could have made the pattern
   ////// to segment inputs ///////// and matches the associated full precision triggerprimitives to the detected pattern.
   //////////////////////////////////
-
-  MatchingOutput Mout = PhiMatching(Sout);
-  MO[SectIndex] = Mout;
+  
+  //MatchingOutput Mout = PhiMatching(Sout);
+  
+  std::vector<MatchingOutput> Mout_Hold = PhiMatching_Hold(Sout_Hold);
+  
+ // MO[SectIndex] = Mout;
 
   /////////////////////////////////
   //////// Calculate delta //////// Once we have matched the hits we calculate the delta phi and theta between all
   ////////    ph and th    //////// stations present.
   /////////////////////////////////
 
- std::vector<std::vector<DeltaOutput>> Dout = CalcDeltas(Mout);////
+ //std::vector<std::vector<DeltaOutput>> Dout = CalcDeltas(Mout);////
+ 
+ std::vector<std::vector<std::vector<DeltaOutput>>> Dout_Hold = CalcDeltas_Hold(Mout_Hold);
 
 
   /////////////////////////////////
@@ -270,31 +315,72 @@ for(int SectIndex=0;SectIndex<NUM_SECTORS;SectIndex++){//perform TF on all 12 se
   ////// Best 3 tracks/sector /////  Here ghost busting is done to delete tracks which are comprised of the same associated stubs.
   /////////////////////////////////
 
-  std::vector<BTrack> Bout = BestTracks(Dout);
-   PTracks[SectIndex] = Bout;
+ // std::vector<BTrack> Bout = BestTracks(Dout);
+  
+  std::vector<std::vector<BTrack>> Bout_Hold = BestTracks_Hold(Dout_Hold);
+  
+  // PTracks[SectIndex] = Bout;
+   for(int bx=0;bx<3;bx++){
+   		PTracks_BX[SectIndex][bx] = Bout_Hold[bx];
+	}
 
    
  } // End loop: for(int SectIndex=0;SectIndex<NUM_SECTORS;SectIndex++)
 
 
  ///////////////////////////////////////
- /// Collect Muons from all sectors ////
- ///////////////////////////////////////
-
+ /// Collect Muons from all sectors //// and BX windows 
+ /////////////////////////////////////// 
+										
  std::vector<BTrack> PTemp[NUM_SECTORS];
- std::vector<BTrack> AllTracks;
+ std::vector<BTrack> AllTracks, AllTracks_PreDuplicationCancellation;
  for (int i=0; i<NUM_SECTORS; i++) PTemp[i] = PTracks[i];
+ 
 
-
+for(int bx=0;bx<3;bx++){
  	for(int j=0;j<36;j++){
 
 
-			if(PTemp[j/3][j%3].phi)//no track
-				AllTracks.push_back(PTemp[j/3][j%3]);
+			//if(PTemp[j/3][j%3].phi)//no track
+			//	AllTracks.push_back(PTemp[j/3][j%3]);
+			
+			if(PTracks_BX[j/3][bx][j%3].phi)//no track
+				AllTracks_PreDuplicationCancellation.push_back(PTracks_BX[j/3][bx][j%3]);
+				
+ 	}
+}
 
-		
+for(unsigned int i1=0;i1<AllTracks_PreDuplicationCancellation.size();i1++){
 
- 	}
+	bool dup = false;
+	
+	int ebx = 20, sindex = -1;
+	for(std::vector<ConvertedHit>::iterator A = AllTracks_PreDuplicationCancellation[i1].AHits.begin();A != AllTracks_PreDuplicationCancellation[i1].AHits.end();A++){
+		if(A->TP().getCSCData().bx < ebx){
+			ebx = A->TP().getCSCData().bx;
+		}
+		sindex = A->SectorIndex();
+	}
+
+	for(unsigned int i2=i1+1;i2<AllTracks_PreDuplicationCancellation.size();i2++){
+		
+		int ebx2 = 20, sindex2 = -1;
+		for(std::vector<ConvertedHit>::iterator A2 = AllTracks_PreDuplicationCancellation[i1].AHits.begin();A2 != AllTracks_PreDuplicationCancellation[i1].AHits.end();A2++){
+			if(A2->TP().getCSCData().bx < ebx2){
+				ebx2 = A2->TP().getCSCData().bx;
+			}
+			sindex2 = A2->SectorIndex();
+		}
+		
+		if(ebx == ebx2 && AllTracks_PreDuplicationCancellation[i1].theta == AllTracks_PreDuplicationCancellation[i2].theta &&
+		   AllTracks_PreDuplicationCancellation[i1].phi == AllTracks_PreDuplicationCancellation[i2].phi && AllTracks_PreDuplicationCancellation[i1].winner.Rank() == AllTracks_PreDuplicationCancellation[i2].winner.Rank() &&
+		   sindex == sindex2 && sindex != -1 && sindex2 != -1){dup = true;}
+		
+	}
+	
+	if(!dup)
+		AllTracks.push_back(AllTracks_PreDuplicationCancellation[i1]);
+}
 
   ///////////////////////////////////
   /// Make Internal track if ////////
@@ -302,7 +388,7 @@ for(int SectIndex=0;SectIndex<NUM_SECTORS;SectIndex++){//perform TF on all 12 se
   /////////////////////////////////// 
   
   std::vector<l1t::RegionalMuonCand> tester1;
-  std::vector<std::pair<int,l1t::RegionalMuonCand>> holder;
+  std::vector<std::pair<int,l1t::RegionalMuonCand>> holder, holder2;
 
   for(unsigned int fbest=0;fbest<AllTracks.size();fbest++){
 
@@ -338,6 +424,7 @@ for(int SectIndex=0;SectIndex<NUM_SECTORS;SectIndex++){//perform TF on all 12 se
 		int ebx = 20, sebx = 20;
 		int phis[4] = {-99,-99,-99,-99};
 
+
 		for(std::vector<ConvertedHit>::iterator A = AllTracks[fbest].AHits.begin();A != AllTracks[fbest].AHits.end();A++){
 
 			if(A->Phi() != -999){
@@ -436,6 +523,7 @@ for(int SectIndex=0;SectIndex<NUM_SECTORS;SectIndex++){//perform TF on all 12 se
 
 		tempTrack.phis = ps;
 		tempTrack.thetas = ts;
+		tempTrack.deltas = AllTracks[fbest].deltas;
 
 		// // Before Mulhearn cleanup, May 11
 		// unsigned long xmlpt_address = 0;
@@ -443,6 +531,7 @@ for(int SectIndex=0;SectIndex<NUM_SECTORS;SectIndex++){//perform TF on all 12 se
 		
 		// After Mulhearn cleanup, May 11
 		unsigned long xmlpt_address = ptAssignment_.calculateAddress(tempTrack, es, mode);
+		//std::cout<<"address = "<<xmlpt_address<<"\n";
 		float xmlpt = ptAssignment_.calculatePt(xmlpt_address);
 
 		tempTrack.pt = xmlpt*1.4;
@@ -457,6 +546,7 @@ for(int SectIndex=0;SectIndex<NUM_SECTORS;SectIndex++){//perform TF on all 12 se
 
 		float theta_angle = l1t::calc_theta_rad_from_int( AllTracks[fbest].theta ); 
 		float eta = l1t::calc_eta_from_theta_rad( theta_angle );
+		
 
 		thisTrack.set_phi_loc_deg  ( l1t::calc_phi_loc_deg( thisTrack.Phi_loc_int() ) );
 		thisTrack.set_phi_loc_rad  ( l1t::calc_phi_loc_rad( thisTrack.Phi_loc_int() ) );
@@ -494,18 +584,21 @@ for(int SectIndex=0;SectIndex<NUM_SECTORS;SectIndex++){//perform TF on all 12 se
 
 		if(!ME13 && fabs(eta) > 1.1) {
 		  // // Extra debugging output - AWB 29.03.16
-		  // std::cout << "Input: eBX = " << ebx << ", seBX = " << sebx << ", pt = " << xmlpt*1.4 
-		  // 	    << ", phi = " << AllTracks[fbest].phi << ", eta = " << eta 
-		  // 	    << ", theta = " << AllTracks[fbest].theta << ", sign = " << 1 
-		  // 	    << ", quality = " << mode << ", trackaddress = " << 1 
-		  // 	    << ", sector = " << sector << std::endl;
-		  // std::cout << "Output: BX = " << ebx << ", hwPt = " << outCand.hwPt() << ", hwPhi = " << outCand.hwPhi() 
-		  // 	    << ", hwEta = " << outCand.hwEta() << ", hwSign = " << outCand.hwSign() 
-		  // 	    << ", hwQual = " << outCand.hwQual() << ", link = " << outCand.link()
-		  // 	    << ", processor = " << outCand.processor() 
-		  // 	    << ", trackFinderType = " << outCand.trackFinderType() << std::endl;
+		  std::cout << "Input: eBX = " << ebx << ", seBX = " << sebx << ", pt = " << xmlpt*1.4 
+		 	 << ", phi = " << AllTracks[fbest].phi << ", eta = " << eta 
+		 	 << ", theta = " << AllTracks[fbest].theta << ", sign = " << 1 
+		 	 << ", quality = " << mode << ", trackaddress = " << 1 
+		 	 << ", sector = " << sector << std::endl;
+		  std::cout << "Output: BX = " << ebx << ", hwPt = " << outCand.hwPt() << ", hwPhi = " << outCand.hwPhi() 
+		 	 << ", hwEta = " << outCand.hwEta() << ", hwSign = " << outCand.hwSign() 
+		 	 << ", hwQual = " << outCand.hwQual() << ", link = " << outCand.link()
+		 	 << ", processor = " << outCand.processor() 
+		 	 << ", trackFinderType = " << outCand.trackFinderType() << std::endl;
 			holder.push_back(outPair);
 			thisTrack.set_isGMT( 1 );
+			
+			if(outCand.hwEta() == -240 || outCand.hwEta() == 239)
+				std::cout<<"interesting event "<<ev.id().event()<<"\n";
 		}
 		OutputTracks->push_back( thisTrack );
 		OutTracks->push_back( thisTrack.CreateEMTFTrack() );
@@ -541,9 +634,11 @@ ev.put( OutputCands, "EMTF");
 
 void L1TMuonEndCapTrackProducer::beginJob()
 {
+
 }
 void L1TMuonEndCapTrackProducer::endJob()
 {
+
 }
 #include "FWCore/Framework/interface/MakerMacros.h"
 DEFINE_FWK_MODULE(L1TMuonEndCapTrackProducer);
diff --git a/L1Trigger/L1TMuonEndCap/plugins/L1TMuonEndCapTrackProducer.h b/L1Trigger/L1TMuonEndCap/plugins/L1TMuonEndCapTrackProducer.h
index 4ebe300..a8d6c3a 100644
--- a/L1Trigger/L1TMuonEndCap/plugins/L1TMuonEndCapTrackProducer.h
+++ b/L1Trigger/L1TMuonEndCap/plugins/L1TMuonEndCapTrackProducer.h
@@ -72,8 +72,6 @@ public:
   ///////////////////////////////////////
   ///////////////////////////////////////
   
-  
-  
   const float ptscale[33] = { 
   	-1.,   0.0,   1.5,   2.0,   2.5,   3.0,   3.5,   4.0,
     4.5,   5.0,   6.0,   7.0,   8.0,  10.0,  12.0,  14.0,  
diff --git a/L1Trigger/L1TMuonEndCap/src/PatternRecognition.cc b/L1Trigger/L1TMuonEndCap/src/PatternRecognition.cc
index b6bd379..deaa6eb 100644
--- a/L1Trigger/L1TMuonEndCap/src/PatternRecognition.cc
+++ b/L1Trigger/L1TMuonEndCap/src/PatternRecognition.cc
@@ -34,6 +34,8 @@ PhiMemoryImage patterns[PATTERN_SIZE] = {pattern8, pattern9, pattern6, pattern7,
   	for(int zone=0;zone<4;zone++){
 	
 		
+		//std::cout<<"zone "<<zone<<"\n";
+		//Merged[zone].Print();
   
   		for(int b=0;b<192;b++){//loop over stips of detector zones//was 128 now 192 to accomodate 
   							   //larger phi scale used in neighboring sectors algorithm
@@ -44,14 +46,14 @@ PhiMemoryImage patterns[PATTERN_SIZE] = {pattern8, pattern9, pattern6, pattern7,
 	
 				bool zona[12] = {false}; //Clear out station presence
 		
-				if((b-15) < 63){ 														//////Due to bug in BitShift function. 
+				if((b-15) < 63){ 														//////Due to bug in BitShift function when shifting by >= field length. 
 					patt[y].BitShift(b-15);			 									//////Can try and fix later before uploading to CMSSW.
 				}																		//////
 				else if((b-15) < 127){													//////
-					patt[y].BitShift(63);patt[y].BitShift(b-78);						//////
+					patt[y].BitShift(63);patt[y].BitShift(1);patt[y].BitShift(b-79);						//////
 				}																		//////
 				else{																	//////
-					patt[y].BitShift(63);patt[y].BitShift(63);patt[y].BitShift(b-141);  //////
+					patt[y].BitShift(63);patt[y].BitShift(1);patt[y].BitShift(63);patt[y].BitShift(1);patt[y].BitShift(b-143);  //////
 				}																		//////
 			
 			
@@ -112,13 +114,15 @@ PhiMemoryImage patterns[PATTERN_SIZE] = {pattern8, pattern9, pattern6, pattern7,
 	
 			int qr = ranka_t[zone][k-1], ql = ranka_t[zone][k+1], qc = ranka_t[zone][k];
 			
-			//if(qc && verbose)
-			//	std::cout<<"\n"<<k<<":qc = "<<qc<<" straight: "<<stra[zone][k]<<"  lya: "<<lya[zone][k]<<std::endl; 
+			
 		
 			if(k==0){qr=0;}
 			if(k==191){ql=0;}//was 127
 		
 			if((qc <= ql) || (qc < qr)){qc = 0;}
+			
+			//if(qc )
+			//  std::cout<<"\n"<<k<<":qc = "<<qc<<" straight: "<<stra[zone][k]<<"  lya: "<<lya[zone][k]<<std::endl; 
 		
 			ranka[zone][k] = qc;
 		}
@@ -145,9 +149,13 @@ PhiMemoryImage patterns[PATTERN_SIZE] = {pattern8, pattern9, pattern6, pattern7,
  	PatternOutput tmp;
 	std::vector<PatternOutput> output (3,tmp);
 	
-	for(int i=0;i<3;i++)
+	for(int i=0;i<3;i++){
+		
+		//std::cout<<"begin pattern dection on bx group "<<i<<"\n";
+		
 		output[i] = DetectPatterns(Zones[i]);
 		
+	}
 		
  	return output;
  
diff --git a/L1Trigger/L1TMuonEndCap/src/PrimitiveConverter.cc b/L1Trigger/L1TMuonEndCap/src/PrimitiveConverter.cc
index 76ac569..7557f57 100644
--- a/L1Trigger/L1TMuonEndCap/src/PrimitiveConverter.cc
+++ b/L1Trigger/L1TMuonEndCap/src/PrimitiveConverter.cc
@@ -122,7 +122,7 @@ std::vector<ConvertedHit> PrimitiveConverter::convert(std::vector<TriggerPrimiti
 	if(ring == 4){Id += 9;}
 
 	//if(endcap == 1 && sector == 1)//
-	if( (SectIndex ==  (endcap - 1)*6 + sector - 1 )  || IsNeighbor )
+	if( (SectIndex ==  (endcap - 1)*6 + sector - 1 ) || IsNeighbor )
 	{
 	
 		
@@ -279,6 +279,8 @@ std::vector<ConvertedHit> PrimitiveConverter::convert(std::vector<TriggerPrimiti
 	ph_tmp = ((eightstrip*factor)>>10);
 	int phShift = (ph_tmp>>5);
 	int phLow = 0;
+	
+	//std::cout<<"\nph_tmp = "<<ph_tmp<<"\n";
 
 	if(ph_reverse){
 	
@@ -345,7 +347,7 @@ std::vector<ConvertedHit> PrimitiveConverter::convert(std::vector<TriggerPrimiti
 	
 		}
 		
-		//std::cout<<"nid = "<<neighborId<<", idl = "<<idl<<"\n";
+		//std::cout<<"\n\nnid = "<<neighborId<<", idl = "<<idl<<"\n";
 		
 		th_tmp = Th_LUT_St1_Neighbor_[subId-1][SectIndex][idl -1][wire];
 		//std::cout<<"th_tmpr = "<<th_tmp<<"\n";
@@ -394,7 +396,7 @@ std::vector<ConvertedHit> PrimitiveConverter::convert(std::vector<TriggerPrimiti
 		//}
 		//else{
 			th_corr = Th_Corr_Neighbor_[subId-1][SectIndex][corrIndex-1][index];
-			//std::cout<<"th_corr["<<subId-1<<"]["<<SectIndex<<"]["<<corrIndex-1<<"] = "<<th_corr<<"\n";
+			//std::cout<<"th_corr["<<subId-1<<"]["<<SectIndex<<"]["<<corrIndex-1<<"]["<<index<<"] = "<<th_corr<<"\n";
 		//}
 		
 		
@@ -404,13 +406,18 @@ std::vector<ConvertedHit> PrimitiveConverter::convert(std::vector<TriggerPrimiti
 		
 		th_tmp += th_corr;                  //add correction to th_tmp
 		//std::cout<<"th_tmp = "<<th_tmp<<"\n";
-		if(th_tmp < 0)
+		if(th_tmp < 0 || wire == 0)
 			th_tmp = 0;
+			
+		if(th_tmp > th_coverage)//this is one change that I'm not sure if it does anything good or not
+			th_tmp = th_coverage;	
+		
+		
 		th_tmp &= 0x3f;                     //keep only lowest 6 bits
 		//std::cout<<"th_tmp = "<<th_tmp<<"\n";
 		//std::cout<<"coverage = "<<th_coverage<<"\n";
 		
-		if(th_tmp < th_coverage){
+		if(th_tmp <= th_coverage){
 		
 			//if(ring == 1){LUTi += 9;}  //change because new Verilog3 sp_tf treats ME11b with LUT's of ME11a
 			
@@ -479,7 +486,7 @@ std::vector<ConvertedHit> PrimitiveConverter::convert(std::vector<TriggerPrimiti
 	//applying ph_offsets
 	if(sub == 1){
 		zhit = ph_hit + ph_offsets_neighbor[station-1][phOffIndex-1][pz];
-		//std::cout<<"\nph_hit = "<<ph_hit<<" and ph_offsets_neighbor["<<station-1<<"]["<<phOffIndex-1<<"]["<<pz<<"] = "<<ph_offsets_neighbor[station-1][phOffIndex-1][pz]<<"\n";
+		//std::cout<<"ph_hit = "<<ph_hit<<" and ph_offsets_neighbor["<<station-1<<"]["<<phOffIndex-1<<"]["<<pz<<"] = "<<ph_offsets_neighbor[station-1][phOffIndex-1][pz]<<"\n";
 	}
 	else{
 			
@@ -497,10 +504,14 @@ std::vector<ConvertedHit> PrimitiveConverter::convert(std::vector<TriggerPrimiti
 	///////////////////////////////////////////////////////
 	
 	
-	//if(SectIndex == 8){
-		//std::cout<<"phi = "<<fph<<", theta = "<<th<<", ph_hit = "<<ph_hit<<",zhit = "<<zhit<<", station = "<<station<<", ring = "<<ring<<", id = "<<Id<<", sector "<<SectIndex<<",sub = "<<sub<<", strip = "<<strip<<", wire = "<<wire<<", IsNeighbor = "<<IsNeighbor<<"\n";
+	//if(SectIndex == 0){
+		//std::cout<<"phi = "<<fph<<", theta = "<<th<<", bx = "<<BX<<", ph_hit = "<<ph_hit<<",zhit = "<<zhit<<", station = "<<station<<", ring = "<<ring<<", id = "<<Id<<", sector "<<SectIndex<<",sub = "<<sub<<", strip = "<<strip<<", wire = "<<wire<<", IsNeighbor = "<<IsNeighbor<<"\n";
+	
 	
-		//std::cout<<BX-3<<" "<<endcap<<" "<<sector<<" "<<sub<<" "<<station<<" 1 "<<quality<<" "<<pattern<<" "<<wire<<" "<<C3.Id()<<" 0 "<<strip<<"\n";
+		//if(C3.Id() > 9)
+		//	std::cout<<BX-3<<" "<<endcap<<" "<<sector<<" "<<sub<<" "<<station<<" 1 "<<quality<<" "<<pattern<<" "<<wire<<" "<<C3.Id() - 9<<" 0 "<<strip<<"\n";
+		//else
+		//	std::cout<<BX-3<<" "<<endcap<<" "<<sector<<" "<<sub<<" "<<station<<" 1 "<<quality<<" "<<pattern<<" "<<wire<<" "<<C3.Id()<<" 0 "<<strip<<"\n";
 	//}
 	
 	/* if(station != 1) */
@@ -517,6 +528,7 @@ std::vector<ConvertedHit> PrimitiveConverter::convert(std::vector<TriggerPrimiti
 		in = 1;
 
 	Hit.SetValues(fph,th,ph_hit,phzvl,station,sub,Id,quality,pattern,wire,strip,BX);
+	Hit.AddTheta(th);
 	Hit.SetTP(C3);
 	Hit.SetZhit(zhit);
 	Hit.SetZoneContribution(zonecontribution);
diff --git a/L1Trigger/L1TMuonEndCap/src/PtAssignment.cc b/L1Trigger/L1TMuonEndCap/src/PtAssignment.cc
index 3337bb0..4ea0a2f 100644
--- a/L1Trigger/L1TMuonEndCap/src/PtAssignment.cc
+++ b/L1Trigger/L1TMuonEndCap/src/PtAssignment.cc
@@ -927,6 +927,17 @@ unsigned long EmtfPtAssignment::calculateAddress( L1TMuon::InternalTrack track,
     //// Calculate Delta Phi and Eta Combinations ////
     //////////////////////////////////////////////////
 	
+	for(int d=0;d<6;d++){
+	
+		dphi[d] = track.deltas[0][d];
+		deta[d] = track.deltas[1][d];
+		
+		if(verbose) cout<<"dphi["<<d<<"] = "<<dphi[d]<<" and dth[d] = "<<deta[d]<<"\n";
+	
+	}
+	
+	/*
+	
     if(phis[0] > 0 && phis[1] > 0){ // 1 - 2
       dphi[0] = phis[1] - phis[0];
       deta[0] = etas[1] - etas[0];
@@ -952,7 +963,7 @@ unsigned long EmtfPtAssignment::calculateAddress( L1TMuon::InternalTrack track,
       deta[5] = etas[3] - etas[2];
     }
 
-
+	*/
     if(verbose){
       if (mode_inv==3) // 1-2
 	{
@@ -1145,7 +1156,10 @@ unsigned long EmtfPtAssignment::calculateAddress( L1TMuon::InternalTrack track,
 	// Make Pt LUT Address
 	int dPhi12_ = fabs(dPhi12);
 	int sign12_ = dPhi12Sign > 0 ? 1 : 0;
+	
+	//std::cout<<"dTheta12 = "<<dTheta12;
 	int dTheta12_ = getdTheta(dTheta12);
+	//std::cout<<"dTehta12_ = "<<dTheta12_;
 	int CLCT1_ = getCLCT(CLCT1);
 	int CLCT1Sign_ = CLCT1_ > 0 ? 1 : 0;
 	CLCT1_ = abs(CLCT1_);
@@ -1154,7 +1168,9 @@ unsigned long EmtfPtAssignment::calculateAddress( L1TMuon::InternalTrack track,
 	CLCT2_ = abs(CLCT2_);
 	int FR1_ = FR1;
 	int FR2_ = FR2;
+	//std::cout<<"TrackEta = "<<TrackEta;
 	int eta_ = getEtaInt(TrackEta, 5);
+	//std::cout<<"eta_ = "<<eta_;
 	int Mode_ = mode_inv;
       
 	Address += ( dPhi12_ & ((1<<9)-1))    << (0);
@@ -1465,7 +1481,7 @@ unsigned long EmtfPtAssignment::calculateAddress( L1TMuon::InternalTrack track,
 	int Mode_ = mode_inv;
       
 	Address += ( dPhi13_ & ((1<<7)-1))    << (0);
-	Address += ( dPhi34_ & ((1<<6)-1))    << (0+7);
+	Address += ( dPhi34_ & ((1<<5)-1))    << (0+7);
 	Address += ( sign13_  & ((1<<1)-1))   << (0+7+5);
 	Address += ( sign34_  & ((1<<1)-1))   << (0+7+5+1);
 	Address += ( dTheta14_ & ((1<<3)-1))  << (0+7+5+1+1);
